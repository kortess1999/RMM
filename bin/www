#!/usr/bin/env node

/**
 * Module dependencies.
 */

var app = require('../app');
var debug = require('debug')('rmm:server');
var http = require('http');
const moment = require('moment');

/**
 * Get port from environment and store in Express.
 */

var port = normalizePort(process.env.PORT || '3000');
app.set('port', port);

/**
 * Create HTTP server.
 */

var server = http.createServer(app);

/**
 * Listen on provided port, on all network interfaces.
 */
//Данные по модулям
const DB=require('../database/pbdb');
var Tmodules={};
//Проверка ошибок
async function ParseAndImportErrors(mod){
  if(!mod.errorType.length) return;
  if(mod.errorType[0]==='@')mod.errorType=mod.errorType.substr(1);
  const errors=mod.errorType.split('@');
  for(let i=0;i<errors.length;i++)
  {
    let isSolved=await DB.query(`SELECT create_time FROM modules_errors WHERE module_id=${mod.login} AND err_type='${errors[i]}' AND solve_time IS NULL`);
    console.log(isSolved);
    if(!isSolved.length)
      await DB.query(`INSERT INTO modules_errors (module_id,err_type,create_time) VALUES (${mod.login},'${errors[i]}','${mod.lastContact.format('YYYY-MM-DD HH:mm:ss')}')`);
  }
  mod.errors=errors.join(', ');
}
async function checkModulePass(login,pass){
    let password=await DB.query(`SELECT password FROM modules WHERE id=${login}`);
  //console.log(password);
  if(password.password===pass) return true;
    return false;
}

//Обработка полученных данных
const io = require('socket.io')(server);
io.on('connection', (client) => {
  console.log(`Connected!: ${Object.keys(client)}`);
  client.on('login_data',(data)=>{
    console.log(`Получили данные логина:${JSON.stringify(data)}`);
    if(!checkModulePass(data.login,data.password))
    {
      client.emit('relogin');
      return;
    }
    else
      client.emit('login:ok');
    client.login=data.login;
    client.password=data.password;
    Tmodules[client.login]={
      module:client,
      login:data.login,
      password:data.password,
      lastContact:moment(),
      errorType:'Нет данных',
      state:{},
      functions:{
        relogin(){
          this.module.emit('relogin');
        },
        checkState(){
          this.module.emit('checkState');
        },
        restart(){
          this.module.emit('restart');
        }
      }
    };
  });
  client.on('common_data',(data)=>{
    if(typeof client.login=="undefined")
    {
      client.emit('relogin');
      return
    }
    console.log(`Получили данные:${data}`);
    //Изменение состояния
    Tmodules[client.login].lastContact=moment();
    Tmodules[client.login].state.temperature=parseFloat(data.temperature);
    Tmodules[client.login].state.belowWaterLevel=parseInt(data.belowWaterLevel);
    Tmodules[client.login].state.upperWaterLevel=parseInt(data.upperWaterLevel);
    Tmodules[client.login].state.visits=parseInt(data.visits);
    //Проверка состояния модуля
    Tmodules[client.login].errorType="";
    //температура
    if(typeof Tmodules[client.login].state.temperature==="number")
    {
      if(Tmodules[client.login].state.temperature>50)Tmodules[client.login].errorType+='@Высокая температура';
      if(Tmodules[client.login].state.temperature<-20)Tmodules[client.login].errorType+='@Низкая температура';
    }
    else Tmodules[client.login].errorType+='@Нет данных по температуре';

    //уровень воды
    if([0,1].includes(Tmodules[client.login].state.belowWaterLevel)&&[0,1].includes(Tmodules[client.login].state.upperWaterLevel)) {
      if (!Tmodules[client.login].state.belowWaterLevel) Tmodules[client.login].errorType += '@Мало воды';
      if (Tmodules[client.login].state.upperWaterLevel) Tmodules[client.login].errorType += '@Избыток воды';
    }
    else Tmodules[client.login].errorType+='@Нет данных по уровню воды';
    ParseAndImportErrors(Tmodules[client.login]);
    //Здесь добавить запрос на добавление в БД
    console.log(`Получили данные:${JSON.stringify(data)}`);
  });
  client.on('payment_data',(data)=>{
    console.log(`Получили данные:${JSON.stringify(data)}`);
  });

});
module.exports=Tmodules;

server.listen(port);
server.on('error', onError);
server.on('listening', onListening);

/**
 * Normalize a port into a number, string, or false.
 */

function normalizePort(val) {
  var port = parseInt(val, 10);

  if (isNaN(port)) {
    // named pipe
    return val;
  }

  if (port >= 0) {
    // port number
    return port;
  }

  return false;
}

/**
 * Event listener for HTTP server "error" event.
 */

function onError(error) {
  if (error.syscall !== 'listen') {
    throw error;
  }

  var bind = typeof port === 'string'
    ? 'Pipe ' + port
    : 'Port ' + port;

  // handle specific listen errors with friendly messages
  switch (error.code) {
    case 'EACCES':
      console.error(bind + ' requires elevated privileges');
      process.exit(1);
      break;
    case 'EADDRINUSE':
      console.error(bind + ' is already in use');
      process.exit(1);
      break;
    default:
      throw error;
  }
}

/**
 * Event listener for HTTP server "listening" event.
 */

function onListening() {
  var addr = server.address();
  var bind = typeof addr === 'string'
    ? 'pipe ' + addr
    : 'port ' + addr.port;
  debug('Listening on ' + bind);
}
